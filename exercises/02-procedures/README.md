# Chapter 1.2: Procedures and the Processes They Generate

> "The ability to visualize the consequences of the actions under consideration
> is crucial to becoming an expert programmer."
> — SICP 1.2

A procedure is a pattern for the *local evolution* of a process. In this chapter
we examine the *global* behavior - the "shape" of processes generated by procedures.

## Linear Recursion vs Iteration

Consider factorial. In Scheme:

```scheme
;; Recursive process - builds up deferred operations
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

;; Iterative process - constant space
(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

The recursive version builds a chain: `(* 6 (* 5 (* 4 (* 3 (* 2 1)))))`

The iterative version maintains state: `product × counter → new-product`

In Seq, both patterns translate naturally - but the stack makes the "state" explicit!

## Tree Recursion

Fibonacci is the classic example:

```scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

This generates a tree of calls - exponential time! The iterative version
is linear. Understanding *why* is key to computational thinking.

## Exercises

These exercises explore the shapes of computational processes.
